<?php

namespace App\Services;

use App\Models\User;
use App\Models\Schedule;
use Illuminate\Support\Facades\Log;
use Google_Client;
use Google_Service_Calendar;
use Google_Service_Calendar_Event;
use Google_Service_Calendar_EventDateTime;
use Google_Service_Calendar_ConferenceData;
use Google_Service_Calendar_CreateConferenceRequest;
use Google_Service_Calendar_ConferenceSolutionKey;
use Exception;

/**
 * Google Calendar Service
 * 
 * Handles Google Calendar event creation and management
 * 
 * @package     Laravel CMS App
 * @subpackage  Services
 * @category    Google Calendar Integration
 * @author      Go Globe CMS Team
 * @since       1.0.0
 */
class GoogleCalendarService
{
    /**
     * Google Client instance
     * 
     * @var Google_Client
     */
    private $googleClient;

    /**
     * Constructor
     */
    public function __construct()
    {
        $this->googleClient = new Google_Client();
        $this->googleClient->setClientId(env('GOOGLE_CLIENT_ID'));
        $this->googleClient->setClientSecret(env('GOOGLE_CLIENT_SECRET'));
        $this->googleClient->addScope(Google_Service_Calendar::CALENDAR);
    }

    /**
     * Create Google Calendar event with Meet link
     * 
     * @param Schedule $schedule
     * @return array
     * @throws Exception
     */
    public function createCalendarEvent(Schedule $schedule): array
    {
        try {
            $trainer = $schedule->trainer;
            $client = $schedule->client;

            // Check if trainer has Google token
            if (!$trainer->google_token) {
                throw new Exception('Trainer not connected to Google Calendar');
            }

            // Set access token
            $this->googleClient->setAccessToken($trainer->google_token);

            // Check if token is expired and refresh if needed
            if ($this->googleClient->isAccessTokenExpired()) {
                if ($this->googleClient->getRefreshToken()) {
                    $newToken = $this->googleClient->fetchAccessTokenWithRefreshToken();
                    if (isset($newToken['error'])) {
                        throw new Exception('Failed to refresh Google access token');
                    }
                    $trainer->google_token = $newToken;
                    $trainer->save();
                } else {
                    throw new Exception('Google access token expired and no refresh token available');
                }
            }

            // Create Calendar service
            $calendarService = new Google_Service_Calendar($this->googleClient);

            // Create event
            $event = new Google_Service_Calendar_Event();
            
            // Set event title
            $event->setSummary("Training Session - {$client->name}");
            
            // Set event description
            $description = "Training session between {$trainer->name} (Trainer) and {$client->name} (Client).\n\n";
            $description .= "Session Details:\n";
            $description .= "- Date: {$schedule->date->format('F j, Y')}\n";
            $description .= "- Time: {$schedule->start_time->format('g:i A')} - {$schedule->end_time->format('g:i A')}\n";
            if ($schedule->notes) {
                $description .= "- Notes: {$schedule->notes}\n";
            }
            $description .= "\nGenerated by Go Globe CMS Training Platform";
            $event->setDescription($description);

            // Set start time
            $startDateTime = new Google_Service_Calendar_EventDateTime();
            $startDateTime->setDateTime($schedule->date->format('Y-m-d') . 'T' . $schedule->start_time->format('H:i:s'));
            $startDateTime->setTimeZone($trainer->timezone ?? 'UTC');
            $event->setStart($startDateTime);

            // Set end time
            $endDateTime = new Google_Service_Calendar_EventDateTime();
            $endDateTime->setDateTime($schedule->date->format('Y-m-d') . 'T' . $schedule->end_time->format('H:i:s'));
            $endDateTime->setTimeZone($trainer->timezone ?? 'UTC');
            $event->setEnd($endDateTime);

            // Add attendees
            $attendees = [
                ['email' => $trainer->email, 'displayName' => $trainer->name],
                ['email' => $client->email, 'displayName' => $client->name]
            ];
            $event->setAttendees($attendees);

            // Create Google Meet conference
            $conferenceData = new Google_Service_Calendar_ConferenceData();
            $createRequest = new Google_Service_Calendar_CreateConferenceRequest();
            $createRequest->setRequestId(uniqid());
            
            $solutionKey = new Google_Service_Calendar_ConferenceSolutionKey();
            $solutionKey->setType('hangoutsMeet');
            $createRequest->setConferenceSolutionKey($solutionKey);
            
            $conferenceData->setCreateRequest($createRequest);
            $event->setConferenceData($conferenceData);

            // Set event visibility and other properties
            $event->setVisibility('private');
            $event->setStatus('confirmed');

            // Insert event into calendar
            $createdEvent = $calendarService->events->insert('primary', $event, [
                'conferenceDataVersion' => 1,
                'sendUpdates' => 'all'
            ]);

            // Extract Meet link
            $meetLink = null;
            if ($createdEvent->getConferenceData() && $createdEvent->getConferenceData()->getEntryPoints()) {
                foreach ($createdEvent->getConferenceData()->getEntryPoints() as $entryPoint) {
                    if ($entryPoint->getEntryPointType() === 'video') {
                        $meetLink = $entryPoint->getUri();
                        break;
                    }
                }
            }

            // Update schedule with Google event details
            $schedule->google_event_id = $createdEvent->getId();
            $schedule->meet_link = $meetLink;
            $schedule->save();

            Log::info('Google Calendar event created', [
                'schedule_id' => $schedule->id,
                'event_id' => $createdEvent->getId(),
                'trainer_id' => $trainer->id,
                'client_id' => $client->id
            ]);

            return [
                'success' => true,
                'event_id' => $createdEvent->getId(),
                'meet_link' => $meetLink,
                'event_url' => $createdEvent->getHtmlLink()
            ];

        } catch (Exception $e) {
            Log::error('Failed to create Google Calendar event', [
                'schedule_id' => $schedule->id,
                'error' => $e->getMessage(),
                'trainer_id' => $schedule->trainer_id
            ]);

            throw new Exception('Failed to create Google Calendar event: ' . $e->getMessage());
        }
    }

    /**
     * Update Google Calendar event
     * 
     * @param Schedule $schedule
     * @return array
     * @throws Exception
     */
    public function updateCalendarEvent(Schedule $schedule): array
    {
        try {
            $trainer = $schedule->trainer;

            if (!$trainer->google_token || !$schedule->google_event_id) {
                throw new Exception('No Google Calendar event to update');
            }

            // Set access token
            $this->googleClient->setAccessToken($trainer->google_token);

            // Check if token is expired and refresh if needed
            if ($this->googleClient->isAccessTokenExpired()) {
                if ($this->googleClient->getRefreshToken()) {
                    $newToken = $this->googleClient->fetchAccessTokenWithRefreshToken();
                    if (isset($newToken['error'])) {
                        throw new Exception('Failed to refresh Google access token');
                    }
                    $trainer->google_token = $newToken;
                    $trainer->save();
                } else {
                    throw new Exception('Google access token expired and no refresh token available');
                }
            }

            // Create Calendar service
            $calendarService = new Google_Service_Calendar($this->googleClient);

            // Get existing event
            $event = $calendarService->events->get('primary', $schedule->google_event_id);

            // Update event details
            $client = $schedule->client;
            $event->setSummary("Training Session - {$client->name}");
            
            $description = "Training session between {$trainer->name} (Trainer) and {$client->name} (Client).\n\n";
            $description .= "Session Details:\n";
            $description .= "- Date: {$schedule->date->format('F j, Y')}\n";
            $description .= "- Time: {$schedule->start_time->format('g:i A')} - {$schedule->end_time->format('g:i A')}\n";
            if ($schedule->notes) {
                $description .= "- Notes: {$schedule->notes}\n";
            }
            $description .= "\nGenerated by Go Globe CMS Training Platform";
            $event->setDescription($description);

            // Update start time
            $startDateTime = new Google_Service_Calendar_EventDateTime();
            $startDateTime->setDateTime($schedule->date->format('Y-m-d') . 'T' . $schedule->start_time->format('H:i:s'));
            $startDateTime->setTimeZone($trainer->timezone ?? 'UTC');
            $event->setStart($startDateTime);

            // Update end time
            $endDateTime = new Google_Service_Calendar_EventDateTime();
            $endDateTime->setDateTime($schedule->date->format('Y-m-d') . 'T' . $schedule->end_time->format('H:i:s'));
            $endDateTime->setTimeZone($trainer->timezone ?? 'UTC');
            $event->setEnd($endDateTime);

            // Update the event
            $updatedEvent = $calendarService->events->update('primary', $schedule->google_event_id, $event, [
                'sendUpdates' => 'all'
            ]);

            Log::info('Google Calendar event updated', [
                'schedule_id' => $schedule->id,
                'event_id' => $schedule->google_event_id,
                'trainer_id' => $trainer->id
            ]);

            return [
                'success' => true,
                'event_id' => $updatedEvent->getId(),
                'meet_link' => $schedule->meet_link,
                'event_url' => $updatedEvent->getHtmlLink()
            ];

        } catch (Exception $e) {
            Log::error('Failed to update Google Calendar event', [
                'schedule_id' => $schedule->id,
                'event_id' => $schedule->google_event_id,
                'error' => $e->getMessage()
            ]);

            throw new Exception('Failed to update Google Calendar event: ' . $e->getMessage());
        }
    }

    /**
     * Delete Google Calendar event
     * 
     * @param Schedule $schedule
     * @return bool
     */
    public function deleteCalendarEvent(Schedule $schedule): bool
    {
        try {
            $trainer = $schedule->trainer;

            if (!$trainer->google_token || !$schedule->google_event_id) {
                return true; // Nothing to delete
            }

            // Set access token
            $this->googleClient->setAccessToken($trainer->google_token);

            // Check if token is expired and refresh if needed
            if ($this->googleClient->isAccessTokenExpired()) {
                if ($this->googleClient->getRefreshToken()) {
                    $newToken = $this->googleClient->fetchAccessTokenWithRefreshToken();
                    if (isset($newToken['error'])) {
                        Log::warning('Failed to refresh token for event deletion', [
                            'schedule_id' => $schedule->id,
                            'trainer_id' => $trainer->id
                        ]);
                        return false;
                    }
                    $trainer->google_token = $newToken;
                    $trainer->save();
                } else {
                    Log::warning('No refresh token available for event deletion', [
                        'schedule_id' => $schedule->id,
                        'trainer_id' => $trainer->id
                    ]);
                    return false;
                }
            }

            // Create Calendar service
            $calendarService = new Google_Service_Calendar($this->googleClient);

            // Delete the event
            $calendarService->events->delete('primary', $schedule->google_event_id, [
                'sendUpdates' => 'all'
            ]);

            Log::info('Google Calendar event deleted', [
                'schedule_id' => $schedule->id,
                'event_id' => $schedule->google_event_id,
                'trainer_id' => $trainer->id
            ]);

            return true;

        } catch (Exception $e) {
            Log::error('Failed to delete Google Calendar event', [
                'schedule_id' => $schedule->id,
                'event_id' => $schedule->google_event_id,
                'error' => $e->getMessage()
            ]);

            return false;
        }
    }

    /**
     * Check if trainer is connected to Google Calendar
     * 
     * @param User $trainer
     * @return bool
     */
    public function isTrainerConnected(User $trainer): bool
    {
        if (!$trainer->google_token || $trainer->role !== 'trainer') {
            return false;
        }

        try {
            $this->googleClient->setAccessToken($trainer->google_token);
            
            // If token is expired, try to refresh
            if ($this->googleClient->isAccessTokenExpired()) {
                if ($this->googleClient->getRefreshToken()) {
                    $newToken = $this->googleClient->fetchAccessTokenWithRefreshToken();
                    if (isset($newToken['error'])) {
                        return false;
                    }
                    $trainer->google_token = $newToken;
                    $trainer->save();
                    return true;
                } else {
                    return false;
                }
            }

            return true;

        } catch (Exception $e) {
            Log::warning('Failed to verify trainer Google connection', [
                'trainer_id' => $trainer->id,
                'error' => $e->getMessage()
            ]);
            return false;
        }
    }

    /**
     * Get available time slots for a trainer from Google Calendar
     * 
     * @param User $trainer
     * @param string $startDate
     * @param string $endDate
     * @return array
     */
    public function getAvailableSlots(User $trainer, string $startDate, string $endDate): array
    {
        try {
            if (!$trainer->google_token || $trainer->role !== 'trainer') {
                throw new Exception('Trainer does not have Google Calendar connected');
            }

            // Set access token
            $this->googleClient->setAccessToken($trainer->google_token);

            // Check if token is expired and refresh if needed
            if ($this->googleClient->isAccessTokenExpired()) {
                if ($this->googleClient->getRefreshToken()) {
                    $newToken = $this->googleClient->fetchAccessTokenWithRefreshToken();
                    if (isset($newToken['error'])) {
                        throw new Exception('Failed to refresh Google access token');
                    }
                    $trainer->google_token = $newToken;
                    $trainer->save();
                } else {
                    throw new Exception('Google access token expired and no refresh token available');
                }
            }

            // Create Calendar service
            $calendarService = new Google_Service_Calendar($this->googleClient);

            // Set time range
            $timeMin = \Carbon\Carbon::parse($startDate)->startOfDay()->toRfc3339String();
            $timeMax = \Carbon\Carbon::parse($endDate)->endOfDay()->toRfc3339String();

            // Get busy times from Google Calendar
            $freebusy = new Google_Service_Calendar_FreeBusyRequest();
            $freebusy->setTimeMin($timeMin);
            $freebusy->setTimeMax($timeMax);
            $freebusy->setItems([
                ['id' => 'primary']
            ]);

            $freebusyResponse = $calendarService->freebusy->query($freebusy);
            $busyTimes = $freebusyResponse->getCalendars()['primary']->getBusy();

            // Convert busy times to array
            $busySlots = [];
            foreach ($busyTimes as $busyTime) {
                $busySlots[] = [
                    'start' => $busyTime->getStart(),
                    'end' => $busyTime->getEnd()
                ];
            }

            // Generate available slots (example: 9 AM to 5 PM, 1-hour slots)
            $availableSlots = [];
            $current = \Carbon\Carbon::parse($startDate);
            $end = \Carbon\Carbon::parse($endDate);

            while ($current->lte($end)) {
                // Skip weekends (optional)
                if ($current->isWeekend()) {
                    $current->addDay();
                    continue;
                }

                // Generate hourly slots from 9 AM to 5 PM
                for ($hour = 9; $hour < 17; $hour++) {
                    $slotStart = $current->copy()->setTime($hour, 0, 0);
                    $slotEnd = $slotStart->copy()->addHour();

                    // Check if this slot conflicts with busy times
                    $isAvailable = true;
                    foreach ($busySlots as $busySlot) {
                        $busyStart = \Carbon\Carbon::parse($busySlot['start']);
                        $busyEnd = \Carbon\Carbon::parse($busySlot['end']);

                        if ($slotStart->lt($busyEnd) && $slotEnd->gt($busyStart)) {
                            $isAvailable = false;
                            break;
                        }
                    }

                    if ($isAvailable && $slotStart->gt(\Carbon\Carbon::now())) {
                        $availableSlots[] = [
                            'start' => $slotStart->toISOString(),
                            'end' => $slotEnd->toISOString(),
                            'start_time' => $slotStart->format('H:i'),
                            'end_time' => $slotEnd->format('H:i'),
                            'date' => $slotStart->format('Y-m-d'),
                            'display' => $slotStart->format('g:i A') . ' - ' . $slotEnd->format('g:i A')
                        ];
                    }
                }

                $current->addDay();
            }

            Log::info('Retrieved available slots for trainer', [
                'trainer_id' => $trainer->id,
                'start_date' => $startDate,
                'end_date' => $endDate,
                'slots_count' => count($availableSlots)
            ]);

            return $availableSlots;

        } catch (Exception $e) {
            Log::error('Failed to get available slots', [
                'trainer_id' => $trainer->id,
                'start_date' => $startDate,
                'end_date' => $endDate,
                'error' => $e->getMessage()
            ]);

            throw new Exception('Failed to get available slots: ' . $e->getMessage());
        }
    }

    /**
     * Alias for createCalendarEvent method
     * 
     * @param Schedule $schedule
     * @return array
     */
    public function createEvent(Schedule $schedule): array
    {
        return $this->createCalendarEvent($schedule);
    }
}